# shellcheck shell=bash
# -*- sh -*-
# vim: syntax=sh
# code: language=shellscript

function readlink_portable() {
	local pathname

	case $# in
		(0)
			{
				printf '%s: missing argument: <symlink>\n' "${FUNCNAME[0]}"
				printf 'usage: %s <symlink>\n' "${FUNCNAME[0]}"
			} >&2
			return 3
			;;
		(1)
			if [ -z "$1" ]; then
				printf '%s: argument must not be empty\n' "${FUNCNAME[0]}" >&2
				return 9
			fi

			pathname="$1"
			;;
		(*)
			{
				printf '%s: too many arguments: %i\n' "${FUNCNAME[0]}" $(($# - 1))
				printf 'usage: %s <symlink>\n' "${FUNCNAME[0]}"
			} >&2
			return 4
			;;
	esac

	readonly pathname


	if [ ! -L "$pathname" ]; then
		printf '%s: %s: not a symlink\n' "${FUNCNAME[0]}" "$pathname" >&2
		return 26
	fi


	# this is rather complicated because POSIX doesn't specifiy a proper utiltiy to read a symlink's target, only `ls`
	# is capable of it

	local ls_out

	ls_out="$(POSIXLY_CORRECT=yes POSIX_ME_HARDER=yes LC_ALL=POSIX LC_CTYPE=POSIX LC_TIME=POSIX ls -dn -- "$pathname" && printf x)"
	ls_out="${ls_out%$'\nx'}"

	# removing <file mode>, <number of links>, <owner name>, <group name>, <size> and <date and time> (where both
	# <owner name> and <group name> are their associated numeric values because of the '-n' option given to `ls`)
	if [[ ! "$ls_out" =~ ^([^[:space:]$' \t']+[[:space:]$' \t']+[0-9]+' '+[0-9]+' '+[0-9]+' '+[0-9]+' '+[A-Za-z]+' '+[0-9]+' '+([0-9]+':'[0-9]+|[0-9]+)' '+"$pathname -> ") ]]; then
		printf '%s: emergency stop: unexpected output of ls\n' "${FUNCNAME[0]}" >&2
		return 123
	fi
	ls_out="${ls_out#"${BASH_REMATCH[1]}"}"

	readonly ls_out


	if [ -t 1 ]; then
		printf '%s\n' "$ls_out"
	else
		printf '%s' "$ls_out"
	fi
}

declare __dotfiles_bash_funcs__sourced_file_pathname
__dotfiles_bash_funcs__sourced_file_pathname="${BASH_SOURCE[0]}"

while [ -L "$__dotfiles_bash_funcs__sourced_file_pathname" ]; do
	declare __dotfiles_bash_funcs__sourced_file_symlink_target_pathname
	__dotfiles_bash_funcs__sourced_file_symlink_target_pathname="$(readlink_portable "$__dotfiles_bash_funcs__sourced_file_pathname" && printf x)"
	__dotfiles_bash_funcs__sourced_file_symlink_target_pathname="${__dotfiles_bash_funcs__sourced_file_symlink_target_pathname%x}"

	if [[ "$__dotfiles_bash_funcs__sourced_file_symlink_target_pathname" =~ ^'/' ]]; then
		__dotfiles_bash_funcs__sourced_file_pathname="$__dotfiles_bash_funcs__sourced_file_symlink_target_pathname"
	else
		declare __dotfiles_bash_funcs__sourced_file_parent_dir_pathname
		__dotfiles_bash_funcs__sourced_file_parent_dir_pathname="$(dirname -- "$__dotfiles_bash_funcs__sourced_file_pathname" && printf x)"
		__dotfiles_bash_funcs__sourced_file_parent_dir_pathname="${__dotfiles_bash_funcs__sourced_file_parent_dir_pathname%$'\nx'}"

		__dotfiles_bash_funcs__sourced_file_pathname="$__dotfiles_bash_funcs__sourced_file_parent_dir_pathname/$__dotfiles_bash_funcs__sourced_file_symlink_target_pathname"

		unset -v __dotfiles_bash_funcs__sourced_file_parent_dir_pathname
	fi

	unset -v __dotfiles_bash_funcs__sourced_file_symlink_target_pathname
done

declare __dotfiles_bash_funcs__dotfiles_dir_pathname
__dotfiles_bash_funcs__dotfiles_dir_pathname="$(dirname -- "$__dotfiles_bash_funcs__sourced_file_pathname" && printf x)"
__dotfiles_bash_funcs__dotfiles_dir_pathname="${__dotfiles_bash_funcs__dotfiles_dir_pathname%$'\nx'}"

if [[ ! "$__dotfiles_bash_funcs__dotfiles_dir_pathname" =~ ^'/' ]]; then
	__dotfiles_bash_funcs__dotfiles_dir_pathname="./$__dotfiles_bash_funcs__dotfiles_dir_pathname"
fi

. "$__dotfiles_bash_funcs__dotfiles_dir_pathname/bash_funcs.d/rmcwd.bash"

unset -v __dotfiles_bash_funcs__dotfiles_dir_pathname \
         __dotfiles_bash_funcs__sourced_file_pathname
