#!/usr/bin/env python3

# Copyright (c) 2023 Michael Federczuk
# SPDX-License-Identifier: MPL-2.0 AND Apache-2.0

import os

from instr import fs, proc
from instructions import InstructionGroup, InstructionsReadError, Pathname, read_instructions

# region environment variables

HOME: str = proc.environ.get("HOME", default="")

if HOME == "":
    print(f"{proc.argv[0]}: HOME environment variable must not be unset nor empty", file=proc.stderr)
    proc.exit(48)

if not os.path.isabs(HOME):
    print(f"{proc.argv[0]}: {HOME}: HOME environment variable must be an absolute pathname", file=proc.stderr)
    proc.exit(49)

XDG_CONFIG_HOME: str = proc.environ.get("XDG_CONFIG_HOME", default=os.path.join(HOME, ".config"))

if not os.path.isabs(XDG_CONFIG_HOME):
    print(
        f"{proc.argv[0]}: {XDG_CONFIG_HOME}: XDG_CONFIG_HOME environment variable must be an absolute pathname",
        file=proc.stderr,
    )
    proc.exit(50)

# endregion

# region args

if len(proc.argv) < 2:
    print(
        f"{proc.argv[0]}: missing argument: <command>\n" +
        f"usage: {proc.argv[0]} [un]install [<home>]",
        file=proc.stderr,
    )
    proc.exit(3)

command_name: str = proc.argv[1]

if command_name == "":
    if len(proc.argv) == 2:
        print(f"{proc.argv[0]}: argument must not be empty", file=proc.stderr)
    else:
        print(f"{proc.argv[0]}: argument 1: must not be empty", file=proc.stderr)

    print(f"usage: {proc.argv[0]} [un]install [<home>]", file=proc.stderr)

    proc.exit(9)

# endregion

match command_name:
    case "install":
        # region args

        dest_dir_pathname: str

        match len(proc.argv):
            case 2:
                dest_dir_pathname = ""

            case 3:
                if proc.argv[2] == "":
                    print(
                        f"{proc.argv[0]}: argument 2: must not be empty\n" +
                        f"usage: {proc.argv[0]} {command_name} [<home>]",
                        file=proc.stderr,
                    )
                    proc.exit(9)

                dest_dir_pathname = proc.argv[2]

            case _:
                print(
                    f"{proc.argv[0]}: too many arguments: {len(proc.argv) - 3}\n" +
                    f"usage: {proc.argv[0]} {command_name} [<home>]",
                    file=proc.stderr,
                )
                proc.exit(4)

        # endregion

        instruction_groups: list[InstructionGroup]
        try:
            root_dir_pathname: str = os.path.relpath(os.path.dirname(__file__), str(proc.getcwd()))

            instruction_groups = read_instructions(
                source_dir_pathname=Pathname(root_dir_pathname),
                home=Pathname(HOME),
                xdg_config_home=Pathname(XDG_CONFIG_HOME),
            )
        except FileNotFoundError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: no such file", file=proc.stderr)
            proc.exit(24)
        except IsADirectoryError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: not a file", file=proc.stderr)
            proc.exit(26)
        except InstructionsReadError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.pathname}:{e.lineno}: {e.msg}", file=proc.stderr)
            proc.exit(51)

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                if dest_dir_pathname != "":
                    file_copy_instruction.target = file_copy_instruction.target.with_pathname(
                        Pathname.create_normalized(
                            os.path.join(
                                dest_dir_pathname,
                                os.path.relpath(str(file_copy_instruction.target.pathname), os.path.abspath(os.sep)),
                            )
                        )
                    )

        print("Going to copy the following files (missing directories will be created):", file=proc.stderr)

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                print(
                    f" * {file_copy_instruction.source.pathname} -> {file_copy_instruction.target.pathname}",
                    file=proc.stderr,
                )

        print("Continue? [y/N] ", end="", file=proc.stderr)

        ans: str
        try:
            ans = input()
        except EOFError:
            ans = ""
            print("", file=proc.stderr)
        except KeyboardInterrupt:
            ans = ""
            print("", file=proc.stderr)

        if not ans.lower().startswith("y"):
            print("Aborted.", file=proc.stderr)
            proc.exit(52)

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                fs.mkdirs(Pathname(os.path.dirname(str(file_copy_instruction.target.pathname))))
                fs.copy(source=file_copy_instruction.source.pathname, target=file_copy_instruction.target.pathname)

        print("\nDone.", file=proc.stderr)

    case "uninstall":
        # region args

        dest_dir_pathname: str

        match len(proc.argv):
            case 2:
                dest_dir_pathname = ""

            case 3:
                if proc.argv[2] == "":
                    print(
                        f"{proc.argv[0]}: argument 2: must not be empty\n" +
                        f"usage: {proc.argv[0]} {command_name} [<home>]",
                        file=proc.stderr,
                    )
                    proc.exit(9)

                dest_dir_pathname = proc.argv[2]

            case _:
                print(
                    f"{proc.argv[0]}: too many arguments: {len(proc.argv) - 3}\n" +
                    f"usage: {proc.argv[0]} {command_name} [<home>]",
                    file=proc.stderr,
                )
                proc.exit(4)

        # endregion

        instruction_groups: list[InstructionGroup]
        try:
            root_dir_pathname: str = os.path.relpath(os.path.dirname(__file__), str(proc.getcwd()))

            instruction_groups = read_instructions(
                source_dir_pathname=Pathname(root_dir_pathname),
                home=Pathname(HOME),
                xdg_config_home=Pathname(XDG_CONFIG_HOME),
            )
        except FileNotFoundError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: no such file", file=proc.stderr)
            proc.exit(24)
        except IsADirectoryError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: not a file", file=proc.stderr)
            proc.exit(26)
        except InstructionsReadError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.pathname}:{e.lineno}: {e.msg}", file=proc.stderr)
            proc.exit(51)

        pathnames_to_remove: list[str] = []

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                target: str = str(file_copy_instruction.target.pathname)

                if dest_dir_pathname != "":
                    target = os.path.join(
                        dest_dir_pathname,
                        os.path.relpath(target, os.path.abspath(os.sep)),
                    )

                pathnames_to_remove.append(target)

        print("Going to remove the following files (if they exist):", file=proc.stderr)

        for pathname in pathnames_to_remove:
            print(f" * {pathname}", file=proc.stderr)

        print("Continue? [y/N] ", end="", file=proc.stderr)

        ans: str
        try:
            ans = input()
        except EOFError:
            ans = ""
            print("", file=proc.stderr)
        except KeyboardInterrupt:
            ans = ""
            print("", file=proc.stderr)

        if not ans.lower().startswith("y"):
            print("Aborted.", file=proc.stderr)
            proc.exit(52)

        removed_count: int = 0

        for pathname in pathnames_to_remove:
            if not fs.exists(Pathname(pathname)):
                continue

            fs.remove(Pathname(pathname))
            removed_count += 1

        print(f"\nDone. (removed {removed_count} file(s))", file=proc.stderr)

    case _:
        print(
            f"{proc.argv[0]}: {command_name}: unknown command\n" +
            f"usage: {proc.argv[0]} [un]install [<home>]",
            file=proc.stderr,
        )
        proc.exit(8)
