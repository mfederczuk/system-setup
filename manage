#!/usr/bin/env python3
# -*- python -*-
# vim: syntax=python
# code: language=python

# Copyright (c) 2023 Michael Federczuk
# SPDX-License-Identifier: MPL-2.0 AND Apache-2.0

from __future__ import annotations

import os
from abc import ABC, abstractmethod

from instr import commoncodes as cc
from instr import fs, proc
from instr.instructions import InstructionGroup, InstructionsReadError, read_instructions
from instr.pathname import Pathname, PathnameComponent

exit_status: cc.ExitStatus  # <https://github.com/python/mypy/issues/6232>

# region environment variables

# region HOME

home_str: str = proc.environ.get("HOME", default="")

if home_str == "":
    exit_status = cc.EnvironmentalVariableUnsetOrEmptyExitStatus(variable_name="HOME")
    exit_status.die_with_argv0()

home_pathname: Pathname = Pathname.create_normalized(home_str)
del home_str

if home_pathname.is_relative():
    exit_status = cc.EnvironmentVariableIsRelativePathnameExitStatus(variable_name="HOME")
    exit_status.die_with_argv0()

# endregion

# region XDG_CONFIG_HOME

xdg_config_home_str: str = proc.environ.get("XDG_CONFIG_HOME", default="")

xdg_config_home_pathname: Pathname

if xdg_config_home_str != "":
    xdg_config_home_pathname = Pathname.create_normalized(xdg_config_home_str)
else:
    xdg_config_home_pathname = home_pathname.appended_with(PathnameComponent(".config"))
del xdg_config_home_str

if xdg_config_home_pathname.is_relative():
    exit_status = cc.EnvironmentVariableIsRelativePathnameExitStatus(variable_name="XDG_CONFIG_HOME")
    exit_status.die_with_argv0()

# endregion

# endregion

# region args

if len(proc.argv) < 2:
    exit_status = cc.MissingArgumentExitStatus(
        usage="[un]install [<home>]",
        is_multiple_args=False,
        arguments="<command>",
    )
    exit_status.die_with_argv0()

if proc.argv[1] == "":
    exit_status = cc.EmptyArgumentExitStatus(
        usage="[un]install [<home>]",
        argument_nr=None if len(proc.argv) == 2 else 1,
    )
    exit_status.die_with_argv0()

command_name: str = proc.argv[1]

# endregion

# region main


def query_for_bool_with_default_false(msg: str) -> bool | None:
    ans: str

    print(msg + " [y/N] ", end="", file=proc.stderr)

    try:
        ans = input()
    except EOFError:
        return None
    except KeyboardInterrupt:
        return None

    return ans.lower().startswith("y")


class UnnamedCommand(ABC):

    @abstractmethod
    def invoke(self: UnnamedCommand) -> cc.ExitStatus:
        raise NotImplementedError("Abstract method is not implemented")


class InstallCommand(UnnamedCommand):

    def invoke(self: InstallCommand) -> cc.ExitStatus:
        # region args

        dest_dir_pathname: Pathname | None

        match len(proc.argv):
            case 2:
                dest_dir_pathname = None

            case 3:
                if proc.argv[2] == "":
                    return cc.EmptyArgumentExitStatus(usage="[<home>]", argument_nr=2)

                dest_dir_pathname = Pathname.create_normalized(proc.argv[2])

            case _:
                return cc.TooManyArgumentsExitStatus(usage="[<home>]", excessive_arguments_count=len(proc.argv) - 3)

        # endregion

        instruction_groups: list[InstructionGroup]
        try:
            root_dir_pathname = Pathname(os.path.relpath(str(Pathname(__file__).dirname()), str(proc.getcwd())))

            instruction_groups = read_instructions(
                source_dir_pathname=root_dir_pathname,
                home=home_pathname,
                xdg_config_home=xdg_config_home_pathname,
            )
        except FileNotFoundError as e:
            return cc.NoSuchItemtypeExitStatus(
                item=e.filename,
                itemtype="file",
            )
        except IsADirectoryError as e:
            return cc.WrongItemtypeExitStatus(
                item=e.filename,
                itemtype="file",
            )
        except InstructionsReadError as e:
            return cc.InstructionsSyntaxExitStatus(
                file_pathname=e.pathname,
                lineno=e.lineno,
                error_message=e.msg,
            )

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                if dest_dir_pathname is not None:
                    file_copy_instruction.target = file_copy_instruction.target.with_pathname(
                        dest_dir_pathname.appended_with(file_copy_instruction.target.pathname)
                    )

        print("Going to copy the following files (missing directories will be created):", file=proc.stderr)

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                print(
                    f" * {file_copy_instruction.source.pathname} -> {file_copy_instruction.target.pathname}",
                    file=proc.stderr,
                )

        ans: bool | None = query_for_bool_with_default_false(msg="Continue?")

        if ans is None:
            print(file=proc.stderr)
            ans = False

        if ans is False:
            print("Aborted.", file=proc.stderr)
            return cc.AbortedExitStatus()

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                fs.mkdirs(file_copy_instruction.target.pathname.dirname())
                fs.copy(source=file_copy_instruction.source.pathname, target=file_copy_instruction.target.pathname)

        print("\nDone.", file=proc.stderr)

        return cc.SuccessExitStatus()


class UninstallCommand(UnnamedCommand):

    def invoke(self: UninstallCommand) -> cc.ExitStatus:
        # region args

        dest_dir_pathname: Pathname | None = None

        match len(proc.argv):
            case 2:
                dest_dir_pathname = None

            case 3:
                if proc.argv[2] == "":
                    return cc.EmptyArgumentExitStatus(
                        usage="[<home>]",
                        argument_nr=2,
                    )

                dest_dir_pathname = Pathname.create_normalized(proc.argv[2])

            case _:
                return cc.TooManyArgumentsExitStatus(
                    usage="[<home>]",
                    excessive_arguments_count=len(proc.argv) - 3,
                )

        # endregion

        instruction_groups: list[InstructionGroup]
        try:
            root_dir_pathname = Pathname(os.path.relpath(str(Pathname(__file__).dirname()), str(proc.getcwd())))

            instruction_groups = read_instructions(
                source_dir_pathname=root_dir_pathname,
                home=home_pathname,
                xdg_config_home=xdg_config_home_pathname,
            )
        except FileNotFoundError as e:
            return cc.NoSuchItemtypeExitStatus(
                item=e.filename,
                itemtype="file",
            )
        except IsADirectoryError as e:
            return cc.WrongItemtypeExitStatus(
                item=e.filename,
                itemtype="file",
            )
        except InstructionsReadError as e:
            return cc.InstructionsSyntaxExitStatus(
                file_pathname=e.pathname,
                lineno=e.lineno,
                error_message=e.msg,
            )

        pathnames_to_remove: list[Pathname] = []

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                target: Pathname = file_copy_instruction.target.pathname

                if dest_dir_pathname is not None:
                    target = dest_dir_pathname.appended_with(target)

                pathnames_to_remove.append(target)

        print("Going to remove the following files (if they exist):", file=proc.stderr)

        for pathname in pathnames_to_remove:
            print(f" * {pathname}", file=proc.stderr)

        ans: bool | None = query_for_bool_with_default_false(msg="Continue?")

        if ans is None:
            print(file=proc.stderr)
            ans = False

        if ans is False:
            print("Aborted.", file=proc.stderr)
            return cc.AbortedExitStatus()

        removed_count: int = 0

        for pathname in pathnames_to_remove:
            if not fs.exists(pathname):
                continue

            fs.remove(pathname)
            removed_count += 1

        print(f"\nDone. (removed {removed_count} file(s))", file=proc.stderr)

        return cc.SuccessExitStatus()


COMMAND_MAP: dict[str, UnnamedCommand] = {
    "install": InstallCommand(),
    "uninstall": UninstallCommand(),
}

command: UnnamedCommand | None = COMMAND_MAP.get(command_name)

if command is None:
    exit_status = cc.UnknownCommandExitStatus(
        usage="[un]install [<home>]",
        command_name=command_name,
    )
    exit_status.die_with_argv0()


command_exit_status: cc.ExitStatus = command.invoke()

if command_exit_status.is_not_success():
    argv0: str = proc.argv[0]

    command_exit_status.die(
        message_prefixes=[argv0, command_name],
        usage_prefix=f"{argv0} {command_name}",
    )

# endregion
