#!/usr/bin/env python3
# -*- python -*-
# vim: syntax=python
# code: language=python

# Copyright (c) 2023 Michael Federczuk
# SPDX-License-Identifier: MPL-2.0 AND Apache-2.0

import os

from instr import fs, proc
from instr.instructions import InstructionGroup, InstructionsReadError, read_instructions
from instr.pathname import Pathname, PathnameComponent

# region environment variables

# region HOME

home_str: str = proc.environ.get("HOME", default="")

if home_str == "":
    print(f"{proc.argv[0]}: HOME environment variable must not be unset nor empty", file=proc.stderr)
    proc.exit(48)

home_pathname: Pathname = Pathname.create_normalized(home_str)
del home_str

if home_pathname.is_relative():
    print(f"{proc.argv[0]}: {home_pathname}: HOME environment variable must be an absolute pathname", file=proc.stderr)
    proc.exit(49)

# endregion

# region XDG_CONFIG_HOME

xdg_config_home_str: str = proc.environ.get("XDG_CONFIG_HOME", default="")

xdg_config_home_pathname: Pathname

if xdg_config_home_str != "":
    xdg_config_home_pathname = Pathname.create_normalized(xdg_config_home_str)
else:
    xdg_config_home_pathname = home_pathname.appended_with(PathnameComponent(".config"))
del xdg_config_home_str

if xdg_config_home_pathname.is_relative():
    print(
        f"{proc.argv[0]}: {xdg_config_home_pathname}: " +
        "XDG_CONFIG_HOME environment variable must be an absolute pathname",
        file=proc.stderr,
    )
    proc.exit(50)

# endregion

# endregion

# region args

if len(proc.argv) < 2:
    print(
        f"{proc.argv[0]}: missing argument: <command>\n" +
        f"usage: {proc.argv[0]} [un]install [<home>]",
        file=proc.stderr,
    )
    proc.exit(3)

command_name: str = proc.argv[1]

if command_name == "":
    if len(proc.argv) == 2:
        print(f"{proc.argv[0]}: argument must not be empty", file=proc.stderr)
    else:
        print(f"{proc.argv[0]}: argument 1: must not be empty", file=proc.stderr)

    print(f"usage: {proc.argv[0]} [un]install [<home>]", file=proc.stderr)

    proc.exit(9)

# endregion

match command_name:
    case "install":
        # region args

        dest_dir_pathname: Pathname | None

        match len(proc.argv):
            case 2:
                dest_dir_pathname = None

            case 3:
                if proc.argv[2] == "":
                    print(
                        f"{proc.argv[0]}: argument 2: must not be empty\n" +
                        f"usage: {proc.argv[0]} {command_name} [<home>]",
                        file=proc.stderr,
                    )
                    proc.exit(9)

                dest_dir_pathname = Pathname.create_normalized(proc.argv[2])

            case _:
                print(
                    f"{proc.argv[0]}: too many arguments: {len(proc.argv) - 3}\n" +
                    f"usage: {proc.argv[0]} {command_name} [<home>]",
                    file=proc.stderr,
                )
                proc.exit(4)

        # endregion

        instruction_groups: list[InstructionGroup]
        try:
            root_dir_pathname = Pathname(os.path.relpath(str(Pathname(__file__).dirname()), str(proc.getcwd())))

            instruction_groups = read_instructions(
                source_dir_pathname=root_dir_pathname,
                home=home_pathname,
                xdg_config_home=xdg_config_home_pathname,
            )
        except FileNotFoundError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: no such file", file=proc.stderr)
            proc.exit(24)
        except IsADirectoryError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: not a file", file=proc.stderr)
            proc.exit(26)
        except InstructionsReadError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.pathname}:{e.lineno}: {e.msg}", file=proc.stderr)
            proc.exit(51)

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                if dest_dir_pathname is not None:
                    file_copy_instruction.target = file_copy_instruction.target.with_pathname(
                        dest_dir_pathname.appended_with(file_copy_instruction.target.pathname)
                    )

        print("Going to copy the following files (missing directories will be created):", file=proc.stderr)

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                print(
                    f" * {file_copy_instruction.source.pathname} -> {file_copy_instruction.target.pathname}",
                    file=proc.stderr,
                )

        print("Continue? [y/N] ", end="", file=proc.stderr)

        ans: str
        try:
            ans = input()
        except EOFError:
            ans = ""
            print("", file=proc.stderr)
        except KeyboardInterrupt:
            ans = ""
            print("", file=proc.stderr)

        if not ans.lower().startswith("y"):
            print("Aborted.", file=proc.stderr)
            proc.exit(52)

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                fs.mkdirs(file_copy_instruction.target.pathname.dirname())
                fs.copy(source=file_copy_instruction.source.pathname, target=file_copy_instruction.target.pathname)

        print("\nDone.", file=proc.stderr)

    case "uninstall":
        # region args

        dest_dir_pathname: Pathname | None = None

        match len(proc.argv):
            case 2:
                dest_dir_pathname = None

            case 3:
                if proc.argv[2] == "":
                    print(
                        f"{proc.argv[0]}: argument 2: must not be empty\n" +
                        f"usage: {proc.argv[0]} {command_name} [<home>]",
                        file=proc.stderr,
                    )
                    proc.exit(9)

                dest_dir_pathname = Pathname.create_normalized(proc.argv[2])

            case _:
                print(
                    f"{proc.argv[0]}: too many arguments: {len(proc.argv) - 3}\n" +
                    f"usage: {proc.argv[0]} {command_name} [<home>]",
                    file=proc.stderr,
                )
                proc.exit(4)

        # endregion

        instruction_groups: list[InstructionGroup]
        try:
            root_dir_pathname = Pathname(os.path.relpath(str(Pathname(__file__).dirname()), str(proc.getcwd())))

            instruction_groups = read_instructions(
                source_dir_pathname=root_dir_pathname,
                home=home_pathname,
                xdg_config_home=xdg_config_home_pathname,
            )
        except FileNotFoundError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: no such file", file=proc.stderr)
            proc.exit(24)
        except IsADirectoryError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.filename}: not a file", file=proc.stderr)
            proc.exit(26)
        except InstructionsReadError as e:
            print(f"{proc.argv[0]}: {command_name}: {e.pathname}:{e.lineno}: {e.msg}", file=proc.stderr)
            proc.exit(51)

        pathnames_to_remove: list[Pathname] = []

        for instruction_group in instruction_groups:
            for file_copy_instruction in instruction_group.file_copy_instructions:
                target: Pathname = file_copy_instruction.target.pathname

                if dest_dir_pathname is not None:
                    target = dest_dir_pathname.appended_with(target)

                pathnames_to_remove.append(target)

        print("Going to remove the following files (if they exist):", file=proc.stderr)

        for pathname in pathnames_to_remove:
            print(f" * {pathname}", file=proc.stderr)

        print("Continue? [y/N] ", end="", file=proc.stderr)

        ans: str
        try:
            ans = input()
        except EOFError:
            ans = ""
            print("", file=proc.stderr)
        except KeyboardInterrupt:
            ans = ""
            print("", file=proc.stderr)

        if not ans.lower().startswith("y"):
            print("Aborted.", file=proc.stderr)
            proc.exit(52)

        removed_count: int = 0

        for pathname in pathnames_to_remove:
            if not fs.exists(pathname):
                continue

            fs.remove(pathname)
            removed_count += 1

        print(f"\nDone. (removed {removed_count} file(s))", file=proc.stderr)

    case _:
        print(
            f"{proc.argv[0]}: {command_name}: unknown command\n" +
            f"usage: {proc.argv[0]} [un]install [<home>]",
            file=proc.stderr,
        )
        proc.exit(8)
